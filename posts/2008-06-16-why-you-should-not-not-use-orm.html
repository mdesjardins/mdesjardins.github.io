<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mike Desjardins">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="dcterms.date" content="2008-06-16" />
  <title>Why you should not not use ORM</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: 1;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=VT323&display=swap" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="content">
<header id="title-block-header">
<h1 class="title">Why you should not not use ORM</h1>
<p class="date">2008-06-16</p>
</header>
<div class="post">
<p>Yesterday I read a blog post by Kenneth Downs entitled “<a
href="http://database-programmer.blogspot.com/2008/06/why-i-do-not-use-orm.html">Why
I Do Not Use ORM</a>” on his <a
href="http://database-programmer.blogspot.com/">The Database
Programmer</a> blog. It wasn’t the first blog post with gripes about
Object Relational Mapping, and it certainly won’t be the last. For me,
this particular article highlighted a few misconceptions about why and
how ORM should be used, and I thought I might chime in with my own
perspective.</p>
<p><span style="font-weight: bold;">ORM is not a way to avoid
SQL</span><br />
The first thing that stood out for me was this quote:<br />
&gt; “The language SQL is the most widely supported, implemented, and
used way to connect to databases. But since most of us have long lists
of complaints about the language, we end up writing abstraction layers
that make it easier for us to avoid coding SQL directly.”</p>
<p>To his credit, the author wasn’t actually addressing ORM in this
paragraph. However, anyone writing business logic which interacts with a
database, who is unable to write some basic SQL, is like a bull in a
china shop; nothing good will come of it regardless of the tools and
abstraction layers employed.</p>
<p><span style="font-weight: bold;">The Simple Example</span><br />
The next example in the post shows how one would write a row to a
database in only four lines of PHP code – it looks something like this
(I removed the comments):</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode php"><code class="sourceCode php"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="va">$row</span> <span class="op">=</span> getPostStartingWith(<span class="st">&quot;inp_&quot;</span>)<span class="ot">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="va">$table_id</span> <span class="op">=</span> myGetPostVarFunction(<span class="st">&#39;table_id&#39;</span>)<span class="ot">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="op">!</span><span class="cn">S</span>QLX_Insert(<span class="va">$table_id</span><span class="ot">,</span><span class="va">$row</span>)) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> myFrameworkErrorReporting()<span class="ot">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>I don’t know PHP, but I think the code is reading every field in a
posted form that starts with inp_, generates an insert statement
straight from the ID’s on the form fields, and writes an insert
statement with the results.</p>
<p>Perhaps it’s unfair to criticize this code because “it’s just a
simple example,” but if this code is being held up as an example of how
short and simple non-ORM code can be, one does have to wonder * When the
database schema changes, does the HTML need to be updated so that the
form fields match the database schema? * Where are the transactions?
What if I need to insert into several tables and roll back the
transaction if one fails? * Does the handy SQLX_insert method prevent
SQL injection attacks?</p>
<p>He goes on to say that this task is made even easier by <a
href="http://database-programmer.blogspot.com/2008/06/using-data-dictionary.html">using
a data dictionary</a> to generate the SQL. After reading the “Using a
Data Dictionary” article, one has to wonder whether or not the author
realizes that it is a very crude form of ORM.</p>
<p><span style="font-weight: bold;">What about Business
Logic?</span><br />
Kenneth Downs tries to head-off any arguments about business logic
before they come up, knowing that ORM evangelists will argue that the
domain objects can encapsulate essential business logic for the
application. His response?<br />
&gt; “The SQLX_Insert() routine can call out to functions (fast) or
objects (much slower) that massage data before and after the insert
operation. I will be demonstrating some of these techniques in future
essays, but of course the best permforming and safest method is to use
triggers.”</p>
<p>For me, this sounds alarm bells. Triggers slow down transactions.
Triggers are in your database, which is often your system’s biggest
bottleneck. Triggers silently do things behind your back without telling
you. Triggers change databases from vast, efficient places to store
relational data, into a lumbering behemoth interpreting procedural code
inside big iron.</p>
<p>Conversely, business logic that can be easily distributed across many
smaller web servers scales horizontally. The domain layer is a fantastic
place to embed simple data massaging – sadly, I often see a pile of
persistent entities with getters and setters that don’t do anything.</p>
<p><span style="font-weight: bold;">Counter Example: The Disaster
Scenario</span><br />
Lastly, Ken (can I call him that? What is the ettiquite for this sort of
thing, anyway?) shows an example of a piece of code that is likely to
cause hundreds of unneeded reads to the database in an untuned ORM-based
system. I don’t dispute this; in fact, I <a
href="http://mikedesjardins.net/blog/2008/03/pizza-shop-2-totaling-jpa-order-use.html">posted</a>
about an almost identical nightmare scenario myself a while ago.</p>
<p>For this, I go back to my “bull in a china shop” analogy. Programmers
can write horrible code in any language, with any tool. Layers of
abstraction are a double-edged sword, because you need to understand
what they are doing for you. But it’s not the tool’s fault; it’s the
person misusing it.</p>
<p><span style="font-weight: bold;">Computer Science’s
Vietnam</span><br />
In 2004, Ted Neward famously called ORM <a
href="http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx">Computer
Science’s Vietnam</a>. Encouraged by early successes, we got sucked into
the quagmire. There are plenty of reasons to be frustrated with ORM, but
I’m not sure I agree with Ken’s. I try to hit the 80/20 rule with ORM,
and use it where it makes sense. When I get into a convoluted
transaction or need to do a large batch of operations, I’m not afraid to
dive into SQL and do the work in a stored procedure. I think it’s a good
mix. How about you?</p>
</div>
</div>
</div>
</div>
</body>
</html>
