<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mike Desjardins">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="dcterms.date" content="2015-07-17" />
  <title>What’s a (Good) REST API?</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: 1;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=VT323&display=swap" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="content">
<header id="title-block-header">
<h1 class="title">What’s a (Good) REST API?</h1>
<p class="date">2015-07-17</p>
</header>
<article>
<p><em>(This post originally appeared on Burnside Digital’s blog on July
12, 2013. Alas, Burnside Digital’s blog is no more, so I’ve reposted it
here.)</em></p>
<p>Recently, a colleague who is a front-end developer asked me what the
qualities were for a good REST API. He had been experimenting with <a
href="http://angularjs.org">AngularJS</a> and wanted to get a rough idea
of whether or not he could expect the resource objects returned by
Angular’s $resource factory to work nicely with them.</p>
<p>Strangely, this was a question hard to pin down an answer for. I’ve
worked with RESTful APIs for years and had a good idea what made a good
REST API (“I know one when I see it”), but never really given much
thought to it. <a
href="http://web.archive.org/web/20140707035207/http://en.wikipedia.org/wiki/Roy_Fielding">Roy
Fielding</a> first defined REST in his <a
href="http://web.archive.org/web/20140707035207/http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">doctoral
dissertation</a> back in 2000, but that tome was a lot thicker than the
quick bullet-points my colleague was looking for.</p>
<p>RESTfulness is something that happens in degrees. I think I might
classify it thusly:</p>
<h3
id="not-restful-even-though-the-api-creators-might-claim-that-its-restful-these-alone-dont-make-an-api-restful">Not
RESTful, even though the API creators might claim that it’s RESTful
These alone don’t make an API RESTful:</h3>
<ul>
<li>Uses HTTP or HTTPS</li>
<li>Returns XML and/or JSON</li>
</ul>
<p>Occasionally you’ll run into some misguided folks who think that the
above two points are all it takes to slap the REST seal-of-approval on
their APIs. Ironically, REST pedants will tell you that specifying the
protocol or format not only is inadequate qualification for RESTfulness,
but it actually runs afoul of the spirit of REST.</p>
<p>Warning signs that a self-proclaimed REST interface that isn’t:</p>
<ul>
<li>Verbs are in your URL (e.g., http://example.com/reservation/get or
http://example.com/business/search)</li>
<li>You are using POSTDATA to send query parameters even though you
aren’t changing the server’s application state.</li>
</ul>
<h3 id="mostly-restful">Mostly RESTful</h3>
<p>A mostly (and I’d claim adequately) RESTful interface has these
qualities:</p>
<ul>
<li>Uses URLs to refer to resources. These resources are the “nouns” in
the system. Examples of a resource might be an account, a transaction, a
user, an appointment, etc.</li>
<li>Uses the four best-known, well-recognized “HTTP Verbs”, and defines
them semantically to mean the following “CRUD” operations:</li>
<li>GET – read a resource or list of resources</li>
<li>POST – create a new resource</li>
<li>PUT – modify an existing resource</li>
<li>DELETE – delete a resource</li>
<li>You might wonder how you actually <em>do</em> something like, e.g.,
a payment, in a system designed so noun-centrically like this. It seems
actions/verbs have no place in it. However, even in these cases you are
creating a transaction. So you’d POST/create a payment resource.
Everything is expressed in terms of resource lifecycle events.</li>
<li>Uses semantically appropriate error codes. E.g., 404 means the
resource isn’t found. A 401 means you aren’t authorized to view it. A
422 means something about the data or request was malformed.</li>
</ul>
<h3 id="hardcore-restful-hypermedia">Hardcore RESTful / Hypermedia</h3>
<p>The highest degree of RESTful APIs I’ll refer to as “Hardcore
RESTful.” They have the following qualities:</p>
<ul>
<li>Doesn’t necessarily define a protocol/transport (e.g., HTTP). As I
said above, pedantic REST nerds will tell you that restricting REST to a
single protocol violates the spirit of REST. The reality is that REST
almost always implies HTTP.</li>
<li>Doesn’t define something like a version number in the URL – a
version isn’t semantically a resource or a part of the resource. Instead
API versioning can be done using something like HTTP header values
(e.g., Accept:), or some other side-band portion of the protocol.</li>
<li>Similarly, it shouldn’t define a desired data format in the URL
(e.g., http://example.com/foo.json), and should instead do that via some
side-band part of the protocol like HTTP headers (e.g., content
Accept:). You can embed versioning and desired format in a MIME type
that is passed as an Accept header like this:
<em>application/vnd.mycompany.myapp-v1+json</em></li>
<li>To take a RESTful interface up to the next level, you can create an
API that builds upon REST and does not return hierarchical data. Instead
it returns URLs to subsets of data. This style of API is usually
referred to as a “Hypermedia API” for its reliance on hyperlinks.
E.g.,</li>
</ul>
<h4 id="bad">BAD</h4>
<pre><code>&lt;account&gt;
  &lt;name&gt;Checking&lt;/name&gt;
  &lt;balance&gt;100.00&lt;/balance&gt;
  &lt;user&gt;
    &lt;name&gt;Elvis Presley&lt;/name&gt;
    &lt;address&gt;Graceland&lt;/address&gt;
    &lt;city&gt;Memphis&lt;/city&gt;
    &lt;state&gt;TN&lt;/state&gt;
  &lt;/user&gt;
&lt;/account&gt;</code></pre>
<h4 id="good">GOOD</h4>
<pre><code>&lt;account&gt;
  &lt;name&gt;Checking&lt;/name&gt;
  &lt;balance&gt;100.00&lt;/balance&gt;
  &lt;user href=&quot;http://example.com/user/elvis-presley&quot;/&gt;
&lt;/account&gt;</code></pre>
<p>The argument for this style of design are that your inner URLs can
change at a later date, and not break the entire API. It also enables
“discovery” of the interface by allowing a client to start at a root
node of the API, following links much like a search-engine spider or bot
would. This also engenders systems to evolve their APIs independently
-theoretically, a client with a generic ability to interpret hypermedia
shouldn’t get tripped up by a less rigid definition of the API.
Proponents of Hypermedia APIs often speak of a concept called <a
href="http://web.archive.org/web/20140707035207/http://en.wikipedia.org/wiki/HATEOAS">“Hypermedia
as the Engine of Application State“</a>, or HATEOAS for short.</p>
<p>Arguments against this style is that, in practice, this manner of API
discoverability is of limited usefulness and actually incurs an overhead
by requiring more API calls than would be otherwise needed.</p>
<h3 id="in-summary">In Summary</h3>
<p>What I told my colleague was this: most REST APIs out there meet the
“mostly RESTful” level of compliance. Given that, most REST client
abstractions will probably work OK if the API is at least at that degree
of RESTfulness (with the caveat that I didn’t wade very deeply into
Angular’s resource library!). If you’re creating a brand new REST API,
it’s good to aim a little higher than that - you’re clients will
appreciate it.</p>
<p>If you want to read more about REST and Hypermedia APIs, Steve
Klabnik has written an <a
href="http://web.archive.org/web/20140707035207/http://blog.steveklabnik.com/posts/2011-07-03-nobody-understands-rest-or-http">excellent</a>
<a
href="http://web.archive.org/web/20140707035207/http://blog.steveklabnik.com/posts/2011-08-07-some-people-understand-rest-and-http">series</a>
of <a
href="http://web.archive.org/web/20140707035207/http://blog.steveklabnik.com/posts/2012-02-23-rest-is-over">blog</a>
<a
href="http://web.archive.org/web/20140707035207/http://blog.steveklabnik.com/posts/2012-02-13-an-api-ontology">posts</a><br />
which expand on these ideas a whole lot more.</p>
</article>
</div>
<nav>
&#x25c4 <a href="2015-12-04-announcing-remotelyawesomejobs-dot-com.html" rel="next">Announcing
RemotelyAwesomeJobs.com</a>
<a href="2015-07-17-conditionally-eager-load-associations-in-rails.html" rel="prev">Conditionally
Eager-load associations in Rails</a> &#x25ba
</nav>
<div class="license">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">
<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a>
<br />
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">
Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
</div>
</div>
</div>
</body>
</html>
